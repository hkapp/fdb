\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}

\newcommand{\ie}[0]{\textit{i.e.}}
\newcommand{\eg}[0]{\textit{e.g.}}

\title{FDB: A Functional Database \\ Design ideas}
%\subtitle{Design Ideas}
\author{Hugo Kapp}

\begin{document}

\maketitle

\section{IR}

\subsection{What is the best IR structure?}

This is not a clear cut question.
It depends a lot on the \textbf{target language}, \ie{} the final output of code generation -- see Section~\ref{sec:targetlanguage}.
It also depends on the optimizations and analyses that we need to perform on the IR.

\subsection{What is the target language for code generation?}
\label{sec:targetlanguage}

Ideally, we would like to generate \textbf{Rust} code.

\textit{Why?}
This has the advantage of being the same language as what the query and language runtimes will be implemented in.
Interfacing of the code should be simpler: simple call interface (no FFI), same type system, (some) memory guarantees...
This can also allow for some of Rust optimizations, \eg{} structure packing and short enums.

Rust also natively supports important language features like polymorphism, which we wouldn't need to implement \textit{fully}\footnote{
	Important caveat here: the most important use of polymorphism comes from the data being processed.
	This is (a) resolved at compilation time in the DB kernel and (b) does not follow Rust's struct packing.
	Rust might still be able to do some smart things with other uses of polymorphism in the generated code.
}.

\textit{Cons.}
Rust might be an annoying language as a target for code generation due to its complex lending mechanism.

\subsubsection{Pros and cons of other target languages}

\textit{TODO}

\end{document}